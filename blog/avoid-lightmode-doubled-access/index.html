<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <base href=/ > <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <meta content="ᓚᘏᗢ zzz...｡oＯ" property=og:description> <meta content=website property=og:type> <meta content=icon.jpg property=og:image> <meta content=icon.jpg name=twitter:image> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{slug:"avoid-lightmode-doubled-access",title:"Light Mode bug should be resolved by doubled request detection not replacing GET and POST",pubdate:"2020-04-05",html:"\u003Cp\u003EWith browser games that many interacts request by users toward databases, there might be a problem called Light Mode bug.\u003C\u002Fp\u003E\n\u003Cp\u003EIt&#39;s Google Chrome on mobile&#39;s feature that you can save time and traffics, and it achieves by forcing all request and responce go through google servers. They receives user&#39;s requests, and parry it with continuous requests so that even if you ara in low traffic bands, you can get the fastest response.\u003C\u002Fp\u003E\n\u003Cp\u003EThis continuous requests makes bug that your DB CRUD will happen twice or more.\u003C\u002Fp\u003E\n\u003Ch2 id=\"main-cause\"\u003Emain cause\u003C\u002Fh2\u003E\n\u003Cp\u003EWhat this makes happened is that site owner codes CRUD with GET requests. It&#39;s really unbelievable but there are some codes like that anyway. To make matters worse, this CRUD requests are from user&#39;s right one request, so they have correc sessions and token.\u003C\u002Fp\u003E\n\u003Cp\u003ELight Mode never make POST request continuous, then it will be resolved by replacing GET with POST, but you might say you are not sure where there is a bad GET requests. Adding to it, you can&#39;t make sure if someone will code wrong again.\u003C\u002Fp\u003E\n\u003Cp\u003ETherefore, you should validate with backend that receives and detects double requests.\u003C\u002Fp\u003E\n\u003Ch2 id=\"1-session-purge\"\u003E1: session purge\u003C\u002Fh2\u003E\n\u003Cp\u003EThis way is really popular measure with famous framework such as Laravel. If the request comes to the API and validates with session, the second request will pass again as it is. However, the first request delete the session the second one will never validate, so you can prevent the latter request, even though the request comes almost same time.\u003C\u002Fp\u003E\n\u003Cp\u003EHowever, this causes one missing case that async requests from a same page wouldn&#39;t receive since they use same session. To detect the only same requests which is that latter from the second request, you should use token with it.\u003C\u002Fp\u003E\n\u003Cp\u003EWith this approach, you can separate if this is an invalid request or just doubled request so that you could lead the doubled request to the valid URL but error page. It would be better UX.\u003C\u002Fp\u003E\n\u003Ch2 id=\"2-token-check-by-read-and-write-handle\"\u003E2: token check by read and write handle\u003C\u002Fh2\u003E\n\u003Cp\u003EYou should error check with R handle at first so all the invalid request whose wrong token could redirect to error. Then, you can separate the invalid one here. Secondally, you lock the W handle to error check again.\u003C\u002Fp\u003E\n\u003Cp\u003EYou can easily lock with select_for_update if you set Database with Repeatable Read. In this case, the first one will make the second or latter request to wait. After you correct the token, you can remove the token here, so the second request or latter will never accepted.\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003Etoken check with R handle(slave), and redirect to error if invalid\u003C\u002Fli\u003E\n\u003Cli\u003Eerror check if valid to avoid the process so it gets faster\u003C\u002Fli\u003E\n\u003Cli\u003Etoken check with W handle(master) with lock\u003C\u002Fli\u003E\n\u003Cli\u003Esecond or latter request will wait, but they are valid(it means they are doubled requests.) \u003C\u002Fli\u003E\n\u003Cli\u003Eredirect them to valid URL, but skip the process because first one has passed certainly\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003EStep 4 is the important because it makes sure this request is the doubled request but valid. The session purge way is enough but not general way, so this might be the best UX.\u003C\u002Fp\u003E\n\u003Ch2 id=\"summary\"\u003Esummary\u003C\u002Fh2\u003E\n\u003Cp\u003EWell, the best thing is to not code wrong. POST requests to CRUD is not rarely seen in any programming company. If you fix this up, you should refactor the code later. Also, I just wonder if the old engineer solved the way like this.\nt\u003C\u002Fp\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.970b8a7b.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main","/client/client.970b8a7b.js")}document.head.appendChild(s)</script> <link href=client/client-d06356dd.css rel=stylesheet> <title>Light Mode bug should be resolved by doubled request detection not replacing GET and POST</title><meta content="Light Mode bug should be resolved by doubled request detection not replacing GET and POST" property=og:title data-svelte=svelte-19wcsm0> <link href=/client/client.970b8a7b.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-d06356dd.css rel=preload as=style><link href=/client/[slug].2a6f2f8d.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials></head> <body> <div id=sapper> <header><a href=/ rel=prefetch>ulwlu</a> <p>ᓚᘏᗢ Just personal blog.</header> <main> <div class=title><h1>Light Mode bug should be resolved by doubled request detection not replacing GET and POST</h1></div> <div class=content><p>With browser games that many interacts request by users toward databases, there might be a problem called Light Mode bug.</p> <p>It's Google Chrome on mobile's feature that you can save time and traffics, and it achieves by forcing all request and responce go through google servers. They receives user's requests, and parry it with continuous requests so that even if you ara in low traffic bands, you can get the fastest response.</p> <p>This continuous requests makes bug that your DB CRUD will happen twice or more.</p> <h2 id=main-cause>main cause</h2> <p>What this makes happened is that site owner codes CRUD with GET requests. It's really unbelievable but there are some codes like that anyway. To make matters worse, this CRUD requests are from user's right one request, so they have correc sessions and token.</p> <p>Light Mode never make POST request continuous, then it will be resolved by replacing GET with POST, but you might say you are not sure where there is a bad GET requests. Adding to it, you can't make sure if someone will code wrong again.</p> <p>Therefore, you should validate with backend that receives and detects double requests.</p> <h2 id=1-session-purge>1: session purge</h2> <p>This way is really popular measure with famous framework such as Laravel. If the request comes to the API and validates with session, the second request will pass again as it is. However, the first request delete the session the second one will never validate, so you can prevent the latter request, even though the request comes almost same time.</p> <p>However, this causes one missing case that async requests from a same page wouldn't receive since they use same session. To detect the only same requests which is that latter from the second request, you should use token with it.</p> <p>With this approach, you can separate if this is an invalid request or just doubled request so that you could lead the doubled request to the valid URL but error page. It would be better UX.</p> <h2 id=2-token-check-by-read-and-write-handle>2: token check by read and write handle</h2> <p>You should error check with R handle at first so all the invalid request whose wrong token could redirect to error. Then, you can separate the invalid one here. Secondally, you lock the W handle to error check again.</p> <p>You can easily lock with select_for_update if you set Database with Repeatable Read. In this case, the first one will make the second or latter request to wait. After you correct the token, you can remove the token here, so the second request or latter will never accepted.</p> <ol> <li>token check with R handle(slave), and redirect to error if invalid</li> <li>error check if valid to avoid the process so it gets faster</li> <li>token check with W handle(master) with lock</li> <li>second or latter request will wait, but they are valid(it means they are doubled requests.) </li> <li>redirect them to valid URL, but skip the process because first one has passed certainly</li> </ol> <p>Step 4 is the important because it makes sure this request is the doubled request but valid. The session purge way is enough but not general way, so this might be the best UX.</p> <h2 id=summary>summary</h2> <p>Well, the best thing is to not code wrong. POST requests to CRUD is not rarely seen in any programming company. If you fix this up, you should refactor the code later. Also, I just wonder if the old engineer solved the way like this. t</p> </div> <div class=meta><p class=date>2020-04-05</div></main> <footer><p><a href=blog>blog</a> <button class=focus:outline-none>want dark theme? </button></footer></div> 